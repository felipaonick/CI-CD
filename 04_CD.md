# ğŸš€ **Continuous Delivery (CD Pipeline)**

---

## ğŸ“Œ **1ï¸âƒ£ Il problema da risolvere**

Senza **CD**:

* âŒ Serve un **code freeze** per testare.
* ğŸ‘¨â€ğŸ’» Gli sviluppatori devono:

  * Fare checkout locale.
  * Costruire lâ€™immagine Docker a mano.
  * Fare `ssh` sul server.
  * Aggiornare file `docker-compose.yml` o manifest Kubernetes a mano.
  * Eseguire `kubectl apply` o riavviare container manualmente.
* ğŸ§‘â€ğŸ’» Solo chi Ã¨ **senior** sa farlo â†’ colli di bottiglia.
* ğŸ˜¬ Il tutto Ã¨ **manuale, lento e soggetto a errori**.

---

## âœ¨ **2ï¸âƒ£ La parola magica: Automazione**

ğŸ‘‰ Con **Continuous Delivery** automatizziamo TUTTO:

1ï¸âƒ£ Se i **test CI** sono âœ…:

* Costruiamo lâ€™app in unâ€™immagine Docker.
* Le diamo un **version tag**.
* Facciamo `push` al **Docker Registry**.

2ï¸âƒ£ Dal sistema di build (es. Jenkins, GitLab CI, GitHub Actions):

* Connettiamo al server o cluster.
* Eseguiamo il **deploy automatico**:

  * Nuovo Pod/container.
  * Applichiamo aggiornamenti manifest YAML.
  * Eseguiamo `kubectl apply`.

---

## ğŸ§° **3ï¸âƒ£ Il flusso CD in pratica**


* Si gestisce tutto con il tool di automazione della build (es. Jenkinsfile, .gitlab-ci.yml)

* Tutta la logica di:

- Verificare il codice localmente (checkout locale)
- Creare una nuova versione della Docker Image
- Aggiornare il file di kubernetes deployment manifest con la nuova versione della Docker Image
- Connetersi al cluster kubernetes
- Applicare il deployment


* Tutta questa logica Ã¨ **automatizzata** in uno script di un Jenkinsfile o in un .gitlab-ci.yml o in un file GitHub Actions. 

![alt](images/CD.png)

* Dunque i passaggi manuali ora sono automatizzati da un tool, un tool CI/CD, un tool creato appositamente per questo scopo di automatizzare il processo

âœ¨ Esempio:

```yaml
if: tests == green
then:
  - build: Docker image
  - tag: vNext
  - push: Docker registry
  - deploy: dev cluster
```

ğŸ”— Tutta la logica Ã¨ in:

* `Jenkinsfile`
* `.gitlab-ci.yml`
* `.github/workflows/*.yml`

âœ… Risultato:

* Niente terminali manuali.
* Niente SSH.
* Zero passaggi dimenticati.

---

## ğŸ”‘ **4ï¸âƒ£ Quanto costa farlo?**

* Serve:

  * ğŸ“Œ Configurare tali tools di automazione del processo (es. Jenkins).
  * Configurare i permessi su Jenkins per poter fare il deploy nell'ambiente di sviluppo e testare il workflow
  * ğŸ”‘ Gestire accessi sicuri.
  * ğŸ§© Scrivere pipeline step-by-step.

ğŸ’¡ Ma:

* Ãˆ un **investimento unico**.
* Impostare l'intero processo (che automatizziamo) di:
    - connessione con il Docker Registry
    - connessione con il cluster
    - connessione con i server 
    - proteggere il tutto e deployare tutto automaticamente 
    Farlo Ci metti **2â€“3 giorni** se sai come farlo.
* ğŸ† Risparmi **mesi** di deploy manuali.

---

## ğŸ“Œ **5ï¸âƒ£ Non Ã¨ solo build: test E2E automatici**

* Cosa avviene dopo che abbiamo distribuito/deployato sull'ambiete di sviluppo? 

Dopo deploy su dev:

* **Facciamo test piÃ¹ estesi**:

  * Test end-to-end â¡ï¸ Click su UI, verifica DB.
  * Test di integrazione con servizi esterni.
  * Test dinamici di sicurezza (es. tentativi SQL injection).

âœ¨ Esempio:

```yaml
jobs:
  - deploy: dev
  - test: e2e + security scan
```

* Dobbiamo testare il deploy in un ambiente di esecuzione per accertarci che la connettivitÃ , la configurazione, l'impostazione, l'infrastruttura sottostante ecc. funzionino correttamente.

* Dobbiamo fare test piÃ¹ estensivi sul funzionamento vero e prorpio del deploy su ambiente dev.

* Quando facciamo merging durante CI pipeline testiamo il codice, la sintassi, e la funzionalitÃ . Questi sono Unit test, test funzionali, vediamo che il codice Ã¨ pulito e che la logica funziona

* QuÃ¬ invece nella CD pipeline dopo aver fatto il deploy automatizzato su ambiente di sviluppo facciamo test sull'intero ambiente dall'inizio alla fine (E2E test):
    - Facciamo i vari click sull'interfaccia utente UI
    - Controlliamo che tutte le API funzionino 
    - Controlliamo che si facciano effettivamente gli aggiornamenti sul DB

![alt](images/e2e-test.png)

* Il punto chiave Ã¨ che non facciamo questi test manualmente ma automattiziamo anche questo.

* Scriviamo test automatizzati end-to-end e di intergrazione perchÃ¨ vogliamo eliminare il piÃ¹ possibile l'intervento umano dal ciclo in ogni fase. Eseguiamo questi test automatizzati nella CD pipeline subito dopo il deployment 

* **Post-Deployment Pipeline checks**:
    - Verifichiamo che l'applicazione funzioni correttamente 
    - Facciamo test per verificare problemi di sicurezza che potrebbero compromettere i nostri sistemi
    
* In questa fase eseguiamo test molto approfonditi su un sistam in esecuzione

---

## âš¡ **6ï¸âƒ£ Chi scrive questi test?**

* ğŸ§© Il team! SÃ¬, serve tempo per scriverli.
* Ma i test girano:

  * **Ogni merge**.
  * **Ogni commit** se serve.
  * **PiÃ¹ volte a settimana** â†’ Risparmio di test manuali enormi.

âœ… Risultato:

* Meno bug.
* Meno sorprese in produzione.

---

## ğŸ—ï¸ **7ï¸âƒ£ Rilascio in fasi**

âœ¨ Dopo `dev`:

* Deploy su ambiente `test` o `staging` (pre-produzione).
* Altra batteria di test.
* Se tutto verde âœ… â†’ Pronti per `prod`.

Questo flusso **CI + CD**:

* Verifica **codice + ambiente**.
* Assicura che lâ€™intera app funzioni prima di andare live.

* Dunque, rilasciamo le modifiche al condice in piÃ¹ fasi, in cui vengono testate a ogni stadio, e questo workflow di distribuzione di una versione fino all'ambiente di staging o di test Ã¨ chiamoato CD (continuous delivery)

---

## ğŸ¯ **8ï¸âƒ£ Impatto reale**

Con **CD Pipeline**:

* ğŸ“¦ Deploy **automatici**.
* ğŸ‘¨â€ğŸ’» Niente piÃ¹ code freeze.
* ğŸš« Niente umani che fanno `ssh` la sera.
* ğŸ§˜ Nessuno in ansia prima del rilascio.
* ğŸ–ï¸ Anche il senior puÃ² andare in ferie: la pipeline lavora per tutti.

---

## Produzione

* Ci rimane un'ultimo step da fare dato chei nostri utenti finali non hanno ancora visto le modifiche al nostro codice

* Stiamo andando verso la produzione con il nostro processo di ralascio completamente automatizzato perchÃ¨ abbiamo gli strumenti per farlo.

* Cosa succede quindi dopo la messa in scena? Se stiamo sviluppando una'applicazion e rivolta ai clienti, e vogliamo rilasciare a loro una nuova funzionalitÃ . Quindi ci chiediamo: cos'altro dobbiamo verificare per essere sicuri al 100% di non rovinare la nostra applicazione a vita?

* Eseguiamo test sulle Performance e ulteriori test sulla conformitÃ  e sicurezza, eseguiamo tutto sulli staging e convalidiamo che tutto sia a posto al 100%

##  ğŸš€ **Continuous Deployment**

---

## ğŸ“Œ **1ï¸âƒ£ Non Ã¨ ancora finita**

âœ… Con **CI** e **CD**:

* Abbiamo validato il codice.
* Abbiamo deploy automatici su **Dev** e **Staging**.
* Maâ€¦ gli **utenti finali** ğŸ‘¥ non vedono ancora le novitÃ !

---

## ğŸ—‚ï¸ **2ï¸âƒ£ Prossimo step: andare in produzione**

ğŸ‘‰ Dopo lo **staging**, serve:

* Ultima validazione ğŸ”

  * âœ… Test di **performance**
  * âœ… Verifiche di **compliance**
  * âœ… Controlli di **sicurezza avanzati**
* Tutto sullo staging â¡ï¸ Ambiente quasi identico alla produzione.

---

## âš™ï¸ **3ï¸âƒ£ Lâ€™ultimo clic: Deploy in Prod**

âœ¨ Di solito:

* Non sempre conviene fare **deploy 100% automatico** in produzione.
* âš™ï¸ Spesso câ€™Ã¨:

  * Una **demo** per il team/PM/sponsor.
  * Un **OK finale** del product owner o di un decision maker.

![alt](images/staging-to-prod.png)

* Dunque Ã¨ comune avere una conferma manuale subito prima del deployment in produzione

âœ… Questo step Ã¨:

* Solo **un bottone** â¡ï¸ `Deploy to Prod`.
* Il **flusso tecnico** Ã¨ **sempre automatico**:

  * Il clic avvia script e pipeline.
  * Anche un non-tecnico puÃ² farlo in **GitHub Actions**, **GitLab**, **Jenkins**, ecc.

---

## ğŸ”‘ **4ï¸âƒ£ Continuous Deployment**

**Definizione**:

* **Continuous Deployment (CD)** = Proseguimento naturale di **Continuous Delivery**.
* Significa che **ogni release testata** puÃ² essere **rilasciata in produzione**:

  * âœ… In automatico **oppure**
  * âœ… Con **approvazione manuale** (1 clic)

![alt](images/CD-to-prod.png)

---

## ğŸ’¡ **5ï¸âƒ£ Vantaggi**

* â±ï¸ Rilasci **rapidi** e frequenti.
* ğŸ”„ Nessun blocco manuale (a parte lâ€™ok finale se serve).
* ğŸ§© La pipeline si occupa di **tutto**:

  * Deploy
  * Configurazioni
  * Scaling, rolling updates, rollback se serve.

---

## ğŸ§© **6ï¸âƒ£ Riassunto finale: CI/CD/CD**

| Fase                         | Obiettivo                                                |
| ---------------------------- | -------------------------------------------------------- |
| âœ… **Continuous Integration** | Integrazione e test continui del codice.                 |
| ğŸš€ **Continuous Delivery**   | Deploy automatici in Dev, Test, Staging.                 |
| ğŸŒ **Continuous Deployment** | Deploy automatico (o semi-automatico) in **Produzione**. |


![alt](images/continuous-deployment.png)

---

## ğŸ¯ **7ï¸âƒ£ Impatto sul team**

Grazie a **Continuous Deployment**:

* ğŸ“Œ **Nessun freeze**, nessuna finestra notturna.
* âœ… QualitÃ  testata a piÃ¹ livelli.
* ğŸ§˜ Nessuno in ansia: lâ€™app Ã¨ **pronta e stabile**.
* ğŸ”— Deployment rapido, sicuro, ripetibile.

---

# ğŸš€ **Deployment Strategies**

---

## ğŸ¯ **1ï¸âƒ£ Il problema residuo**

Anche con:

* âœ… **CI:** Test continui sul codice.
* âœ… **CD:** Deploy automatici su dev, staging, prod.

ğŸ‘‰ Resta **un rischio minimo**:

* ğŸ§© Un **bug nascosto** puÃ² **sfuggire** ai test.
* Anche con il 99% di confidenza â¡ï¸ Rimane quellâ€™**1% di incertezza**.

---

## âš¡ **2ï¸âƒ£ Come ridurre ancora il rischio?**

âœ¨ **Strategie di deploy intelligenti**:

* ğŸ¦ **Canary Deployment**
* ğŸŸ¦ğŸŸ© **Blue-Green Deployment**

---

## ğŸ¦ **3ï¸âƒ£ Canary Deployment**

**Idea chiave**:

* Rilasci la **nuova versione** solo a una piccola percentuale di utenti (es. 1%).
* ğŸ” **Osservi**:

  * Tutto OK? Aumenti al 5%, poi 10%â€¦
  * Progressivo â¡ï¸ fino al 100%.

**Come funziona**:

* Il traffico Ã¨ **splittato** tra:

  * Versione **corrente**.
  * Versione **nuova**.

ğŸ‘‰ Se qualcosa va male â¡ï¸ Blocchi lâ€™espansione al traffico di utenti.

---

## ğŸŸ¦ğŸŸ© **4ï¸âƒ£ Blue-Green Deployment**

**Idea chiave**:

* Hai **2 ambienti identici**:

  * ğŸŸ¦ **Blue** â†’ Versione **attuale**.
  * ğŸŸ© **Green** â†’ Versione **nuova**.

**Come funziona**:

* Deploy nella **Green**.
* Se OK â¡ï¸ Switchi **tutto il traffico** su Green.
* Problema? â¡ï¸ Torni subito a Blue.

âœ… **Rollback istantaneo**.

---

## ğŸ—‚ï¸ **5ï¸âƒ£ Setup richiesto**

Per entrambi serve:

* ğŸ“¡ **Monitoraggio continuo** â†’ Alert automatici.
* ğŸ”— Bilanciatore di carico o routing intelligente.
* ğŸš¦ Strategie di fallback integrate.

ğŸ’¡ Una volta configurato â¡ï¸ Risparmi stress e rischi ogni volta.

---

## ğŸ”‘ **6ï¸âƒ£ Impatto strategico**

âœ¨ Queste strategie:

* ğŸ”’ Riduci al minimo il rischio di bug in produzione.
* ğŸ§˜â€â™‚ï¸ Dai **tranquillitÃ ** al team.
* ğŸš€ Aumenti la **frequenza di deploy**:

  * Meno paura â†’ PiÃ¹ rilasci â†’ Maggiore velocitÃ  di business.

---

## ğŸ§© **7ï¸âƒ£ CI/CD come spina dorsale del DevOps**

Tutto questo fa parte del **core DevOps**:

* **CI/CD = Automazione end-to-end**:

  * Codice â¡ï¸ Test â¡ï¸ Build â¡ï¸ Deploy â¡ï¸ Monitoraggio â¡ï¸ Rollback â¡ï¸ Repeat.

ğŸ‘‰ Elimina lavoro manuale.
ğŸ‘‰ Aumenta la velocitÃ  e la qualitÃ .
ğŸ‘‰ Permette **deploy frequenti e sicuri**.

---

## âœ… **8ï¸âƒ£ Riassunto**

| Strategia           | Come funziona                              | Vantaggio                                |
| ------------------- | ------------------------------------------ | ---------------------------------------- |
| ğŸ¦ **Canary**       | Rilascio graduale a sottoinsiemi di utenti | Rischio controllato, rollout progressivo |
| ğŸŸ¦ğŸŸ© **Blue-Green** | Due ambienti identici, switch di traffico  | Rollback immediato, zero downtime        |

---

## ğŸ“ **9ï¸âƒ£ Conclusione**

ğŸ‘‰ **CI/CD + Strategie di Deploy = DevOps moderno** ğŸš€
ğŸ‘‰ Test, deploy, fallback, monitoraggio **automatizzati**.
ğŸ‘‰ Meno errori, piÃ¹ velocitÃ , piÃ¹ serenitÃ .

---

## ğŸ“š **10ï¸âƒ£ E ora?**

âœ¨ Se questa spiegazione ti ha chiarito le idee:

* âœ… Condividila con un collega!
* âœ… Esercitati a **configurare** questi pattern reali con:

  * **Jenkins**
  * **GitLab CI**
  * **GitHub Actions**
  * **Kubernetes**



